# Задание 3. Найдите ошибки


## Задание

**Дан исходный код приложения, в котором есть ошибки. Одни ошибки — стилистические, а другие не позволят даже запустить приложение. Вам нужно найти все ошибки и исправить их.**

Тестовое приложение — это плагин VS Code для удобного прототипирования интерфейсов с помощью дизайн-системы из первого задания. Вы можете описать в файле `.json` блоки, из которых состоит интерфейс. Плагин добавляет превью (1) и линтер (2) для структуры блоков.

## Выполнение задания

### Этап 1 

Устанавливаем зависимости с помощью `npm i` и пробуем запустить приложение нажатием `F5`

После запуска открывается новое окно VS Code, однако скрипт server.ts показывает две проблемы:
* `Argument of type '(params: InitializeParams) => { capabilities: { textDocumentSync: string; }; }' is not assignable to parameter of type 'RequestHandler<InitializeParams, InitializeResult, InitializeError>'.`

* `Property 'loc' does not exist on type 'AstIdentifier'.`

Первая проблема происходит на этапе инициализации сервера. Читаем сообщение об ошибке, обращаем внимание на строки `Type '{ textDocumentSync: string; }' is not assignable to type 'ServerCapabilities'.` и `Type 'string' is not assignable to type '0 | TextDocumentSyncOptions | 1 | 2 | undefined'`. Отсюда следует, что параметру `textDocumentSync` нельзя присвоить строку. Если навести на него мышку, всплывёт подсказка с документацией, где описано, что это за параметр и какие данные можно ему присвоить. Видим, что `textDocumentSync` определяет, как синхронизуются текстовые документы и является либо объектом `TextDocumentSyncOptions`, либо числом `TextDocumentSyncKind`. Попробуем указать тип `TextDocumentSyncKind`. Открываем документацию `TextDocumentSyncKind`, там описано три типа синхронизации: `None`, `Full` и `Incremental`. Им соответствуют числа от 0 до 2. Судя по описанию типов, нам подходит `Full = 1`, поскольку изначально мы пытались присвоить `textDocumentSync` строку `'always'`, а вариант `Full` означает, что документы всегда синхронизируются путём отправки всего содержимого. Исправляем первоначальный вариант на `textDocumentSync: 1`.

Вторая ошибка связана с тем, что `property.key` не содержит свойства `loc`. `property` соответствует интерфейсу `AstProperty` модуля `json-to-ast`. Откроем данный модуль, чтобы посмотреть, какие свойства есть у `AstProperty`. Видим, что надо указавать `property.loc`, вместо `property.key.loc`. Исправляем ошибку.

### Этап 2

Открываем приложение и пробуем открыть превью для файла `index.json` из первого задания. Вместо структуры блоков видим только надпись `{{content}}`.

В файле `extension.ts` находим функциональное выражение `updateContent`, в котором сгенерированная страница вставляется в превью. Обращаем внимание на регулярное выражение `/{{\s+(\w+)\s+}}/g`, при помощи которого осуществляется замена. Видно, что в местах, куда должна осуществляться вставка в `index.html` из папки `preview` пропущены пробелы, добавляем их.

### Этап 3.

Снова пытаемся открыть превью для `index.json`, на этот раз вообще ничего не показывается. Однако надпись `{{content}}` исчезла, следовательно регулярное выражение теперь работает.

Тут можно вспомнить, что интерфейсные блоки не содержат никакого контента, а их внешний вид полностью определяется добавленными стилями. Следовательно проблема может быть в том, что к блокам неправильно применяются стили.

Открываем `style.css` в папке `preview` и находим ошибку - стили добавляются не к тегу `div`, а к несуществующему классу `.div`. Убираем лишние точки.

### Этап 4.

Отображение превью до сих пор не работает. Остаётся ещё несколько непроверенных мест, где могут оставаться ошибки. Это чтение данных из json, генерация html-разметки и получение `URI` корневой папки приложения - `mediaPath`, который используется в html для подключения внешних файлов.

Корректность последнего проверить проще всего - просто добавляем вручную стили из `style.css` на страницу `index.html`, используя тег `<style>`. После этого отображение блоков появляется, следовательно проблема именно с `mediaPath`.

Открываем `extension.ts` и ищем место, где определяется `mediaPath`, который подставляется в html. Обнаруживаем, что это происходит в `updateContent` с помощью вызова `getMediaPath(context)`. Воспользовавшись выводом в консоль, видим, что `getMediaPath(context)` возвращает `URI` с измененной схемой обращения к ресурсу - `resource`. Смотрим `getMediaPath` и видим, что схема в `URI` заменяется на `resource` с помощью метода `with`.

Отображение веб-содержимого на вкладке VS Code осуществляется при помощи `Webview API`. Ищем в поисковике, какая `URI` схема подходит для загрузки локального контента в `Webview`. [Находим это место в документации](https://code.visualstudio.com/api/extension-guides/webview#loading-local-content). Там написано, что `Webview` по умолчанию не имеет доступа к локальным файлам. Чтобы получить доступ, необходимо изменить `URI` при помощи метода `Webview.asWebviewUri`. Поскольку данный метод просто меняет схему на `vscode-resource`, мы можем заменить `.with({ scheme: "resource"})` на `.with({ scheme: "vscode-resource"})` в `getMediaPath`. После этого отображение превью интерфейса наконец заработает.

### Этап 5.

Проверим работу линтера. Включаем его в настройках VS Code и начинаем редактировать `.json` с нарушением правил, которые проверяет линтер. Сообщения об ошибках не появляются.

Внимательно смотрим файл `linter.ts`. Видим, что в функции `makeLint` создаётся пустой массив `errors`, в который по мере хождения по абстрактному синтаксическому дереву json-файла должны добавляться ошибки, возвращаемые функциями `validateProperty` и `validateObject`. Находим ошибку, состоящую в том, что вместо метода `errors.push(...[foundErrors])` используется `errors.concat(...[foundErrors])`. Первый добавляет найденные ошибки в конец массива `errors` и возвращает новую длину, а второй возвращает массив, соединенный из `errors` и `foundErrors`, не изменяя `errors`. А `makeLint` возвращает именно `errors`, поэтому до сих пор она возвращала пустой массив. Исправляем ошибку.

### Этап 6.

Линтер по-прежнему не подсвечивает ошибки. Найдём место в коде, где используется функция `makeLint`. Находим функцию `validateTextDocument` в `server.ts`. Проверяя её, находим строку `const json = textDocument.uri;`. Сейчас константе `json` присваивается `URI` проверяемого файла, а не его содержимое. Исправляем на `const json = textDocument.getText();`.

После этого линтер работает.

### Этап 7.

Обнаруживаем проблему с типами сообщений линтера - в настройках указываем `Error`, а сообщения показываются как `Information`. Находим соответствующую ошибку в конструкции `switch` функции `GetSeverity` файла `server.ts`. Для случая `Severity.Error` функция возвращала `DiagnosticSeverity.Information`. Исправляем ошибку, проблема исчезает.

### Этап 8.

Теперь подправим codestyle. В приложение уже был включём линтер TSLint и конфиг `tsling.json` с несколькими правилами для него. Расширим эти правила, воспользовавшись пресетом `"tslint:recommended"`. Некоторые правила из пресета, которые на мой взгляд не делают codestyle лучше, я отключил.

С помощью линтера был исправлен ряд недочётов в файлах `configuration.ts`, `extension.ts`, `linter.ts` и `server.ts`. В их числе:
- неиспользованные переменные
- разный стиль кавычек
- больше 1 пустой строки между блоками кода
- лишние пробелы
- объявление неизменяемых переменных с помощью let, а не const


### Подключение стилей и линтера из первых двух заданий
